[<AutoOpen>]
module App.StateMonad

open System

module Operators =

    /// Inject a value into the monadic type
    let inline returnM builder x =
        (^M: (member Return: 'b -> 'c) (builder, x))

    let inline bindM builder m f =
        (^M: (member Bind: 'd * ('e -> 'c) -> 'c) (builder, m, f))

    let inline liftM builder f m =
        let inline ret x = returnM builder (f x)
        bindM builder m ret

    /// Sequential application
    let inline applyM (builder1: ^M1) (builder2: ^M2) f m =
        bindM builder1 f
        <| fun f' ->
            bindM builder2 m
            <| fun m' -> returnM builder2 (f' m')

type State<'T, 'State> = 'State -> 'T * 'State

let getState = fun s -> (s, s)
let putState s = fun _ -> ((), s)
let eval m s = m s |> fst
let exec m s = m s |> snd
let empty = fun s -> ((), s)
let bind k m = fun s -> let (a, s') = m s in (k a) s'

/// The state monad.
/// The algorithm is adjusted from my original work off of Brian Beckman's http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
/// The approach was adjusted from Matthew Podwysocki's http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
type StateBuilder() =
    member this.Return(a): State<'T, 'State> = fun s -> (a, s)
    member this.ReturnFrom(m: State<'T, 'State>) = m
    member this.Bind(m: State<'T, 'State>, k: 'T -> State<'U, 'State>): State<'U, 'State> = bind k m
    member this.Zero() = this.Return()
    member this.Combine(r1, r2) = this.Bind(r1, (fun () -> r2))

    member this.TryWith(m: State<'T, 'State>, h: exn -> State<'T, 'State>): State<'T, 'State> =
        fun env ->
            try
                m env
            with e -> (h e) env

    member this.TryFinally(m: State<'T, 'State>, compensation): State<'T, 'State> =
        fun env ->
            try
                m env
            finally
                compensation ()

    member this.Using(res: #IDisposable, body) =
        this.TryFinally(body res, (fun () -> if not (isNull (box res)) then res.Dispose()))

    member this.Delay(f) = this.Bind(this.Return(), f)

    member this.While(guard, m) =
        if not (guard ())
        then this.Zero()
        else this.Bind(m, (fun () -> this.While(guard, m)))

    member this.For(sequence: seq<_>, body) =
        this.Using
            (sequence.GetEnumerator(), (fun enum -> this.While(enum.MoveNext, this.Delay(fun () -> body enum.Current))))

let state = new StateBuilder()

open Operators

/// Inject a value into the State type
let inline returnM x = returnM state x
/// Sequentially compose two actions, passing any value produced by the first as an argument to the second.
let inline (>>=) m f = bindM state m f
/// Flipped >>=
let inline (=<<) f m = bindM state m f
/// Sequential application
let inline (<*>) f m = applyM state state f m
/// Sequential application
let inline ap m f = f <*> m
/// Transforms a State value by using a specified mapping function.
let inline map f m = liftM state f m
/// Infix map
let inline (<!>) f m = map f m
/// Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
let inline lift2 f a b = returnM f <*> a <*> b
/// Sequence actions, discarding the value of the first argument.
let inline ( *> ) x y = lift2 (fun _ z -> z) x y
/// Sequence actions, discarding the value of the second argument.
let inline (<*) x y = lift2 (fun z _ -> z) x y
/// Sequentially compose two state actions, discarding any value produced by the first
let inline (>>.) m f = bindM state m (fun _ -> f)
/// Left-to-right Kleisli composition
let inline (>=>) f g = fun x -> f x >>= g
/// Right-to-left Kleisli composition
//let inline (<=<) x = flip (>=>) x

//let foldM f s =
//    Seq.fold (fun acc t -> acc >>= (flip f) t) (returnM s)

//let inline sequence s =
//    let inline cons a b = lift2 List.cons a b
//    List.foldBack cons s (returnM [])

//let inline mapM f x = sequence (List.map f x)
